

# Import the modules
import os
import json
import hpsv2
from tqdm import tqdm

# imgs_path can be a list of image paths, with the images generated by the same prompt
# or image path of string type
# or image of PIL.Image.Image type
# result = hpsv2.score(imgs_path, '<prompt>', hps_version="v2.1") 

# Define the folder path and the output file name
# folder_path = "F:/lora_training/hand_gesture_training/images/20_call_test"
# input_dir = "F:/ImageSet/8k_images_captioned"
# input_dir = "F:/ImageSet/test"
input_dir = "F:/ImageSet/openxl2_dataset"

leftover_dir = "F:/ImageSet/openxl2_leftover"

# create the output folder
os.makedirs(leftover_dir, exist_ok=True)

# prefix = 'fashion photo, '
# suffix = ', 8k photo, high quality'
# suffix = ''

for subdir in tqdm(os.listdir(input_dir),position=0):
    subdir_path = os.path.join(input_dir, subdir)
    score_list =[]
    total_file = os.listdir(subdir_path)
    if len(total_file)/3 <=30 :
        continue
    # Loop through the folder and append the image paths to the list
    for file in tqdm(total_file,position=1):
        # Check if the file is an image by its extension
        if file.endswith((".txt")):
            filename,ext = os.path.splitext(file)
            # Join the folder path and the file name to get the full path
            txt_path = os.path.join(subdir_path, file)
            image_path = os.path.join(subdir_path, f'{filename}.jpg')

            content = ''
            # print(txt_path)
            # Append the full path to the list
            with open(txt_path, "r", encoding="utf-8") as f:
                content = f.read()
                f.close()
            try:
                result = hpsv2.score(image_path, content, hps_version="v2.1")[0]
                score_list.append({
                    "filename":filename,
                    # "image_path": image_path,
                    # "caption": content,
                    "score": format(result, '.2f'),
                })
            except: 
                # exception case set score as 0
                score_list.append({
                    "filename":filename,
                    # "image_path": image_path,
                    # "caption": content,
                    "score": format(0, '.2f'),
                })
            # content = prefix + content + suffix
            # with open(full_path, "r+", encoding="utf-8") as out_f:
            #     out_f.write(content)
    
    # Sort the data by the 'image_path' key
    sorted_data = sorted(score_list, key=lambda x: x['score'],reverse=True)
    # save sorted_data to json file
    with open(os.path.join(leftover_dir, subdir + '.json'), 'w', encoding='utf-8') as f:
        json.dump(sorted_data, f, ensure_ascii=False, indent=4)
    if len(sorted_data)>30:
        # Get the leftover items
        leftover = sorted_data[30:]
        output_subset_dir = os.path.join(leftover_dir, subdir)
        
        # create the output folder
        os.makedirs(output_subset_dir, exist_ok=True)
        for item in leftover:
            filename = item['filename']
            image_path = os.path.join(subdir_path, f'{filename}.jpg')
            txt_path = os.path.join(subdir_path, f'{filename}.txt')
            npz_path = os.path.join(subdir_path, f'{filename}.npz')
            

            new_image_path = os.path.join(output_subset_dir, f'{filename}.jpg')
            new_txt_path = os.path.join(output_subset_dir, f'{filename}.txt')
            new_npz_path = os.path.join(output_subset_dir, f'{filename}.npz')
            os.rename(image_path, new_image_path)
            os.rename(txt_path, new_txt_path)
            os.rename(npz_path, new_npz_path)
        # print(len(leftover))
        # print(leftover)


# for file in os.listdir(input_dir):
#     # Check if the file is an image by its extension
#     if file.endswith((".txt")):
#         # Join the folder path and the file name to get the full path
#         full_path = os.path.join(input_dir, file)
#         content = ''
#         print(full_path)
#         # Append the full path to the list
#         with open(full_path, "r", encoding="utf-8") as f:
#             content = f.read()
#             f.close()
#         content = prefix + content + suffix
#         with open(full_path, "r+", encoding="utf-8") as out_f:
#             out_f.write(content)